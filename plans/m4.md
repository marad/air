# Milestone 4: JSON Schema Support
**Structured Outputs - "Type-safe AI responses"**

## Overview
This milestone adds JSON Schema support to AIR, enabling type-safe structured outputs from AI models. Users can define expected response schemas in YAML frontmatter, which get converted to protobuf format for Vertex AI's structured output capabilities. This ensures responses conform to specific data structures and enables better integration with downstream processing.

**Success Criteria**: Users can define JSON schemas in YAML frontmatter that enforce structured AI responses, with automatic validation and pretty-printing of JSON outputs.

---

## Current State Analysis

### What We Have (After M3)
- ✅ Full templating system with includes, placeholders, variables
- ✅ YAML frontmatter parsing infrastructure
- ✅ responseSchema field already exists in Config struct
- ✅ JSON response support via responseMimeType
- ✅ Clean error handling and validation pipeline

### What's Missing
- ❌ JSON Schema parsing from YAML frontmatter
- ❌ Schema-to-protobuf conversion for Vertex AI
- ❌ Structured output validation
- ❌ Pretty-printing of JSON responses
- ❌ Schema validation error handling

---

## Design Decisions

### JSON Schema Format
**Chosen approach**: Standard JSON Schema in YAML frontmatter

**Rationale**:
- Industry standard for describing JSON data structures
- Familiar to developers
- Rich validation capabilities
- Easy to convert to protobuf

**Example**:
```yaml
responseSchema:
  type: object
  properties:
    title:
      type: string
    content:
      type: string
    tags:
      type: array
      items:
        type: string
  required: [title, content]
```

### Schema Conversion
**Approach**: Convert JSON Schema to protobuf format required by Vertex AI

**Rationale**:
- Vertex AI requires protobuf schema format
- Maintains compatibility with existing responseSchema field
- Allows gradual migration from current format

**Implementation**:
- Parse YAML as JSON Schema
- Convert to protobuf Schema message
- Pass to Vertex AI generation config

### Response Handling
**JSON responses**: Pretty-print when responseMimeType is "application/json"

**Rationale**:
- Improves readability of structured outputs
- Maintains backward compatibility
- No impact on text responses

---

## Task Breakdown

### Task 12: JSON Schema Parsing
**Estimated effort**: 1.5 hours

**Goal**: Parse JSON Schema from YAML frontmatter and validate structure.

**Add to `main.go`**:

```go
import (
    "encoding/json"
    "github.com/santhosh-tekuri/jsonschema/v5"
)

// Validate and store JSON schema
type Config struct {
    // ... existing fields ...
    ResponseSchema map[string]interface{} `yaml:"responseSchema"`
}

func (c *Config) ValidateSchema() error {
    if c.ResponseSchema == nil {
        return nil
    }
    
    // Basic validation - ensure it's a valid JSON schema structure
    schemaBytes, err := json.Marshal(c.ResponseSchema)
    if err != nil {
        return fmt.Errorf("invalid response schema: %w", err)
    }
    
    // Use jsonschema library for validation
    compiler := jsonschema.NewCompiler()
    _, err = compiler.Compile(schemaBytes)
    if err != nil {
        return fmt.Errorf("invalid JSON schema: %w", err)
    }
    
    return nil
}
```

**Integration**:
```go
config, markdown, err := parseFrontmatter([]byte(contentWithIncludes))
if err != nil {
    fatalf("Error parsing template: %v", err)
}

if err := config.Validate(); err != nil {
    fatalf("Invalid configuration: %v", err)
}

// NEW: Validate schema if present
if err := config.ValidateSchema(); err != nil {
    fatalf("Invalid response schema: %v", err)
}
```

### Task 13: Schema-to-Protobuf Conversion
**Estimated effort**: 2 hours

**Goal**: Convert JSON Schema to protobuf format for Vertex AI.

**Add to `main.go`**:

```go
import (
    "google.golang.org/genproto/googleapis/cloud/aiplatform/v1"
)

// Convert JSON schema to protobuf Schema
func convertSchemaToProtobuf(schema map[string]interface{}) (*aiplatform.Schema, error) {
    // Convert map to protobuf Schema message
    // This is a simplified implementation - full conversion would be more complex
    
    schemaBytes, err := json.Marshal(schema)
    if err != nil {
        return nil, err
    }
    
    return &aiplatform.Schema{
        Type: aiplatform.Schema_TYPE_UNSPECIFIED, // Would need proper type mapping
        Properties: nil, // Would need recursive property conversion
        // ... other fields
    }, nil
}
```

**Integration into `callVertexAI`**:
```go
func callVertexAI(ctx context.Context, config Config, prompt string) (string, error) {
    // ... existing setup ...
    
    generationConfig := &aiplatform.GenerationConfig{
        // ... existing fields ...
    }
    
    // NEW: Add schema if present
    if config.ResponseSchema != nil {
        schema, err := convertSchemaToProtobuf(config.ResponseSchema)
        if err != nil {
            return "", fmt.Errorf("converting schema to protobuf: %w", err)
        }
        generationConfig.ResponseSchema = schema
    }
    
    // ... rest of function ...
}
```

### Task 14: Response Pretty-Printing
**Estimated effort**: 1 hour

**Goal**: Pretty-print JSON responses for better readability.

**Add to `main.go`**:

```go
import (
    "encoding/json"
    "strings"
)

func formatResponse(response string, mimeType string) string {
    if mimeType == "application/json" {
        var jsonData interface{}
        if err := json.Unmarshal([]byte(response), &jsonData); err == nil {
            // Pretty print JSON
            pretty, err := json.MarshalIndent(jsonData, "", "  ")
            if err == nil {
                return string(pretty)
            }
        }
    }
    return response
}
```

**Integration**:
```go
result, err := callVertexAI(ctx, config, finalMarkdown)
if err != nil {
    fatalf("Error calling AI: %v", err)
}

formattedResult := formatResponse(result, config.ResponseMimeType)
fmt.Println(formattedResult)
```

### Task 15: Schema Validation
**Estimated effort**: 1.5 hours

**Goal**: Validate AI responses against the defined schema.

**Add to `main.go`**:

```go
func validateResponse(response string, schema map[string]interface{}) error {
    if schema == nil {
        return nil
    }
    
    var responseData interface{}
    if err := json.Unmarshal([]byte(response), &responseData); err != nil {
        return fmt.Errorf("response is not valid JSON: %w", err)
    }
    
    // Use jsonschema for validation
    schemaBytes, _ := json.Marshal(schema)
    compiler := jsonschema.NewCompiler()
    sch, _ := compiler.Compile(schemaBytes)
    
    err := sch.Validate(responseData)
    if err != nil {
        return fmt.Errorf("response does not match schema: %w", err)
    }
    
    return nil
}
```

**Integration**:
```go
result, err := callVertexAI(ctx, config, finalMarkdown)
if err != nil {
    fatalf("Error calling AI: %v", err)
}

// NEW: Validate response against schema
if err := validateResponse(result, config.ResponseSchema); err != nil {
    fatalf("Response validation failed: %v", err)
}

formattedResult := formatResponse(result, config.ResponseMimeType)
fmt.Println(formattedResult)
```

---

## Integration & Testing Plan

### End-to-End Test Scenarios

**Scenario 1: Simple object schema**

**Template** (`test_templates/schema/simple_object.md`):
```yaml
---
responseMimeType: application/json
responseSchema:
  type: object
  properties:
    title:
      type: string
    description:
      type: string
  required: [title]
---
Extract the title and description from this text: "The quick brown fox jumps over the lazy dog."
```

**Expected**: Valid JSON object with title and description fields.

**Scenario 2: Array schema**

**Template** (`test_templates/schema/array_schema.md`):
```yaml
---
responseMimeType: application/json
responseSchema:
  type: array
  items:
    type: object
    properties:
      name:
        type: string
      value:
        type: number
---
List 3 programming languages with their popularity scores.
```

**Expected**: Array of objects with name and value fields.

**Scenario 3: Schema validation failure**

**Template** (`test_templates/schema/invalid_response.md`):
```yaml
---
responseMimeType: application/json
responseSchema:
  type: object
  properties:
    count:
      type: integer
  required: [count]
---
Return a string instead of the required object.
```

**Expected**: Validation error about response not matching schema.

---

### Error Handling Test Matrix

| Scenario | Expected Behavior | Exit Code |
|----------|------------------|-----------|
| Valid schema + valid response | Success | 0 |
| Invalid schema syntax | Error: "invalid JSON schema" | 1 |
| Valid schema + invalid response | Error: "response does not match schema" | 1 |
| Non-JSON response with schema | Error: "response is not valid JSON" | 1 |
| No schema | Success (existing behavior) | 0 |

---

## Example Templates to Create

Create in `examples/` directory:

### 1. **examples/structured_analysis.md**
```yaml
---
temperature: 0.0
responseMimeType: application/json
responseSchema:
  type: object
  properties:
    sentiment:
      type: string
      enum: [positive, negative, neutral]
    topics:
      type: array
      items:
        type: string
    confidence:
      type: number
      minimum: 0
      maximum: 1
  required: [sentiment, topics, confidence]
---

Analyze the sentiment of this text: "{{text}}"
```

**Usage**:
```bash
./air examples/structured_analysis.md --var text="I love this product!"
```

### 2. **examples/task_list.md**
```yaml
---
temperature: 0.7
responseMimeType: application/json
responseSchema:
  type: array
  items:
    type: object
    properties:
      task:
        type: string
      priority:
        type: string
        enum: [high, medium, low]
      estimated_hours:
        type: number
    required: [task, priority]
---

Generate a task list for implementing {{feature}}.
```

---

## Code Organization (for this milestone)

```
air/
├── main.go                        # All code still here (refactor in M5)
│                                  # NEW functions:
│                                  # - convertSchemaToProtobuf()
│                                  # - formatResponse()
│                                  # - validateResponse()
│                                  # - Config.ValidateSchema()
├── go.mod                 
├── go.sum
├── .env
├── .env.example
├── Makefile
├── README.md
├── ROADMAP.md
├── AGENTS.md
├── examples/                      # EXPANDED
│   ├── ... (existing)
│   ├── structured_analysis.md     # NEW
│   └── task_list.md               # NEW
├── test_templates/                # EXPANDED
│   ├── ... (existing)
│   └── schema/                    # NEW
│       ├── simple_object.md
│       ├── array_schema.md
│       └── invalid_response.md
├── docs/
│   └── config-reference.md       # UPDATE - Add schema section
└── plans/
    ├── m1.md
    ├── m2.md
    ├── m3.md
    └── m4.md                     # This file
```

---

## Documentation Updates

### Update `README.md`

Add "Structured Outputs" section:

```markdown
## Structured Outputs

Define expected response schemas for type-safe AI outputs:

```yaml
---
responseMimeType: application/json
responseSchema:
  type: object
  properties:
    title:
      type: string
    tags:
      type: array
      items:
        type: string
  required: [title]
---
```

Features:
- JSON Schema validation
- Automatic protobuf conversion for Vertex AI
- Response validation against schema
- Pretty-printed JSON output
```

### Update `docs/config-reference.md`

Add "Response Schema" section:

```markdown
## Response Schema

### responseSchema (object, optional)
Define the expected structure of AI responses using JSON Schema.

When specified with `responseMimeType: application/json`, the AI response will be validated against this schema.

Example:
```yaml
responseSchema:
  type: object
  properties:
    title:
      type: string
    content:
      type: string
    score:
      type: number
      minimum: 0
      maximum: 10
  required: [title, content]
```

Supported JSON Schema features:
- Basic types: string, number, integer, boolean, object, array
- Property validation: required, enum, minimum/maximum
- Array items specification
- Nested objects

Responses are validated after generation and pretty-printed for readability.
```

---

## Definition of Done

Milestone 4 is complete when:
- [ ] JSON Schema parsing from YAML frontmatter works
- [ ] Schema-to-protobuf conversion implemented
- [ ] Structured output validation working
- [ ] JSON responses are pretty-printed
- [ ] Schema validation errors are clear and helpful
- [ ] Example templates with schemas created
- [ ] README updated with structured output documentation
- [ ] Configuration reference updated
- [ ] Code builds without warnings: `make build`
- [ ] Manual end-to-end testing passed for all scenarios
- [ ] Backward compatibility maintained (existing templates work)
- [ ] Ready for type-safe AI response integration

---

## Next Steps (Milestone 5 Preview)

Once M4 is complete, Milestone 5 will refactor the codebase:
- Split `main.go` into multiple packages
- Add proper error types
- Implement logging
- Add unit tests
- Improve configuration management

This will prepare the codebase for production use.

---

## Time Estimate

Total estimated effort: **6-8 hours**

- Task 12 (Schema parsing): 1.5 hours
- Task 13 (Protobuf conversion): 2 hours
- Task 14 (Pretty-printing): 1 hour
- Task 15 (Validation): 1.5 hours
- Integration & testing: 1 hour
- Documentation: 1 hour

**Target completion**: 2-3 development sessions

---

## Risks & Mitigations

### Risk 1: Complex schema conversion
**Problem**: Converting arbitrary JSON Schema to protobuf is complex
**Mitigation**:
- Start with common patterns (object, array, basic types)
- Use existing libraries for schema compilation
- Document limitations clearly
- Add comprehensive test coverage

### Risk 2: Schema validation performance
**Problem**: Validating large responses against complex schemas
**Mitigation**:
- Validation happens client-side after AI generation
- Use efficient JSON schema libraries
- Add timeout for validation if needed
- Consider making validation optional via flag

### Risk 3: Protobuf compatibility
**Problem**: Vertex AI protobuf schema format may change
**Mitigation**:
- Use official Google libraries
- Keep conversion logic isolated
- Add version checking if possible
- Monitor Vertex AI documentation updates

### Risk 4: JSON parsing errors
**Problem**: AI may return malformed JSON despite schema
**Mitigation**:
- Clear error messages for JSON parsing failures
- Graceful fallback to text output
- Log validation failures for debugging
- Consider retry logic with corrected prompts

---

## Notes

- Keep all code in `main.go` for this milestone (refactor in M5)
- Schema validation happens after AI response generation
- Pretty-printing only applies to `application/json` responses
- Invalid schemas should fail early (during config validation)
- Response validation failures should provide clear error messages
- Maintain backward compatibility - existing templates without schemas work unchanged