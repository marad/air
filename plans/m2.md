# Milestone 2: Implementation Plan
**Konfigurowalność - "Parametry generowania"**

## Overview
This milestone adds configurability to AIR by allowing users to control AI generation parameters through YAML frontmatter. Users will be able to customize temperature, topP, maxTokens, safety settings, and model selection without changing code.

**Success Criteria**: Users can control AI behavior (temperature, safety, model) via YAML frontmatter, with sensible defaults when parameters are not specified.

---

## Current State Analysis

### What We Have (After M1)
- ✅ Working end-to-end flow: file → parse → AI → output
- ✅ YAML frontmatter parsing infrastructure
- ✅ Empty `Config` struct ready to be populated
- ✅ Hardcoded AI parameters in `callVertexAI()`:
  - `temperature = 0.0`
  - `topP = 0.95`
  - `maxTokens = 8192`
  - `safetySettings = BLOCK_NONE` for all categories
  - `model = gemini-2.0-flash-001`
  - `ResponseMimeType = "application/json"` (hardcoded)

### What's Missing
- ❌ Config struct fields for AI parameters
- ❌ Reading config values from YAML
- ❌ Passing config to `callVertexAI()`
- ❌ Default value handling
- ❌ Safety threshold mapping from YAML strings to protobuf enums
- ❌ Model name validation
- ❌ Response MIME type configuration

---

## Task Breakdown

### Task 6: Konfiguracja parametrów AI
**Estimated effort**: 1 hour

**Goal**: Read `temperature`, `topP`, `maxTokens`, and `responseMimeType` from YAML frontmatter and use them in AI requests.

**Changes to `Config` struct**:
```go
type Config struct {
    // Generation parameters
    Temperature      *float32 `yaml:"temperature"`       // Pointer to distinguish unset vs 0
    TopP             *float32 `yaml:"topP"`
    MaxTokens        *int32   `yaml:"maxTokens"`
    ResponseMimeType string   `yaml:"responseMimeType"`  // "application/json" or "text/plain"
}
```

**Why pointers?** 
- `temperature: 0.0` is a valid value (different from unset)
- Pointers allow us to distinguish between "not set" (nil) and "set to 0"
- Enables proper default fallback logic

**Update `callVertexAI()` signature**:
```go
func callVertexAI(ctx context.Context, config Config, prompt string) (string, error) {
    // ... existing setup ...
    
    // Apply config with defaults
    temperature := float32(0.0)
    if config.Temperature != nil {
        temperature = *config.Temperature
    }
    
    topP := float32(0.95)
    if config.TopP != nil {
        topP = *config.TopP
    }
    
    maxTokens := int32(8192)
    if config.MaxTokens != nil {
        maxTokens = *config.MaxTokens
    }
    
    responseMimeType := "application/json"
    if config.ResponseMimeType != "" {
        responseMimeType = config.ResponseMimeType
    }
    
    // ... rest of function uses these variables ...
    req := &aiplatformpb.GenerateContentRequest{
        // ...
        GenerationConfig: &aiplatformpb.GenerationConfig{
            Temperature:      &temperature,
            TopP:             &topP,
            MaxOutputTokens:  &maxTokens,
            ResponseMimeType: responseMimeType,
        },
        // ...
    }
}
```

**Update `main.go`**:
```go
// Replace this line:
result, err := callVertexAI(ctx, markdown)

// With:
result, err := callVertexAI(ctx, config, markdown)
```

**Test cases to create** (`test_templates/` directory):
1. `generation_params_full.md` - All parameters specified
```markdown
---
temperature: 0.7
topP: 0.9
maxTokens: 2048
responseMimeType: text/plain
---

Generate a creative story.
```

2. `generation_params_partial.md` - Some parameters specified
```markdown
---
temperature: 1.0
---

Write something creative.
```

3. `generation_params_zero.md` - Temperature set to 0
```markdown
---
temperature: 0.0
---

Give me a deterministic response.
```

4. `generation_params_none.md` - No parameters (test defaults)
```markdown
---
# Empty config
---

Use default parameters.
```

**Acceptance Criteria**:
- [x] Config struct has fields for temperature, topP, maxTokens, responseMimeType
- [x] Values from YAML are correctly parsed into Config
- [x] callVertexAI() uses config values when provided
- [x] Sensible defaults apply when values not specified
- [x] temperature: 0.0 works correctly (not confused with unset)
- [x] Manual testing with all test templates succeeds

---

### Task 7: Konfiguracja safety settings
**Estimated effort**: 1.5 hours

**Goal**: Allow users to configure safety thresholds per harm category via YAML.

**Add to `Config` struct**:
```go
type Config struct {
    // ... existing fields ...
    
    // Safety settings (optional)
    SafetySettings map[string]string `yaml:"safetySettings"`
}
```

**YAML format**:
```yaml
---
safetySettings:
  hate_speech: BLOCK_MEDIUM_AND_ABOVE
  dangerous_content: BLOCK_ONLY_HIGH
  sexually_explicit: BLOCK_NONE
  harassment: BLOCK_LOW_AND_ABOVE
---
```

**Add helper function to convert thresholds**:
```go
func parseHarmCategory(category string) (aiplatformpb.HarmCategory, error) {
    switch category {
    case "hate_speech":
        return aiplatformpb.HarmCategory_HARM_CATEGORY_HATE_SPEECH, nil
    case "dangerous_content":
        return aiplatformpb.HarmCategory_HARM_CATEGORY_DANGEROUS_CONTENT, nil
    case "sexually_explicit":
        return aiplatformpb.HarmCategory_HARM_CATEGORY_SEXUALLY_EXPLICIT, nil
    case "harassment":
        return aiplatformpb.HarmCategory_HARM_CATEGORY_HARASSMENT, nil
    default:
        return 0, fmt.Errorf("unknown harm category: %s", category)
    }
}

func parseSafetyThreshold(threshold string) (aiplatformpb.SafetySetting_HarmBlockThreshold, error) {
    switch threshold {
    case "BLOCK_NONE":
        return aiplatformpb.SafetySetting_BLOCK_NONE, nil
    case "BLOCK_ONLY_HIGH":
        return aiplatformpb.SafetySetting_BLOCK_ONLY_HIGH, nil
    case "BLOCK_MEDIUM_AND_ABOVE":
        return aiplatformpb.SafetySetting_BLOCK_MEDIUM_AND_ABOVE, nil
    case "BLOCK_LOW_AND_ABOVE":
        return aiplatformpb.SafetySetting_BLOCK_LOW_AND_ABOVE, nil
    default:
        return 0, fmt.Errorf("unknown safety threshold: %s", threshold)
    }
}

func buildSafetySettings(config Config) ([]*aiplatformpb.SafetySetting, error) {
    // Default: BLOCK_NONE for all categories
    defaultSettings := []*aiplatformpb.SafetySetting{
        {Category: aiplatformpb.HarmCategory_HARM_CATEGORY_HATE_SPEECH, Threshold: aiplatformpb.SafetySetting_BLOCK_NONE},
        {Category: aiplatformpb.HarmCategory_HARM_CATEGORY_DANGEROUS_CONTENT, Threshold: aiplatformpb.SafetySetting_BLOCK_NONE},
        {Category: aiplatformpb.HarmCategory_HARM_CATEGORY_SEXUALLY_EXPLICIT, Threshold: aiplatformpb.SafetySetting_BLOCK_NONE},
        {Category: aiplatformpb.HarmCategory_HARM_CATEGORY_HARASSMENT, Threshold: aiplatformpb.SafetySetting_BLOCK_NONE},
    }
    
    // If no custom settings, return defaults
    if len(config.SafetySettings) == 0 {
        return defaultSettings, nil
    }
    
    // Build custom settings
    var settings []*aiplatformpb.SafetySetting
    for categoryStr, thresholdStr := range config.SafetySettings {
        category, err := parseHarmCategory(categoryStr)
        if err != nil {
            return nil, fmt.Errorf("safety settings: %w", err)
        }
        
        threshold, err := parseSafetyThreshold(thresholdStr)
        if err != nil {
            return nil, fmt.Errorf("safety settings: %w", err)
        }
        
        settings = append(settings, &aiplatformpb.SafetySetting{
            Category:  category,
            Threshold: threshold,
        })
    }
    
    return settings, nil
}
```

**Update `callVertexAI()`**:
```go
func callVertexAI(ctx context.Context, config Config, prompt string) (string, error) {
    // ... existing setup ...
    
    // Build safety settings
    safetySettings, err := buildSafetySettings(config)
    if err != nil {
        return "", fmt.Errorf("invalid safety settings: %w", err)
    }
    
    // ... rest of function ...
}
```

**Handle errors in `main.go`**:
The `buildSafetySettings()` errors will propagate through `callVertexAI()`, so existing error handling in main is sufficient.

**Test cases to create**:
1. `safety_custom.md` - Custom safety settings
```markdown
---
safetySettings:
  hate_speech: BLOCK_MEDIUM_AND_ABOVE
  harassment: BLOCK_LOW_AND_ABOVE
---

Content that might need safety filtering.
```

2. `safety_all_none.md` - Explicitly set all to BLOCK_NONE
```markdown
---
safetySettings:
  hate_speech: BLOCK_NONE
  dangerous_content: BLOCK_NONE
  sexually_explicit: BLOCK_NONE
  harassment: BLOCK_NONE
---

Unfiltered content request.
```

3. `safety_invalid_category.md` - Invalid category name (should error)
```markdown
---
safetySettings:
  invalid_category: BLOCK_NONE
---

Test error handling.
```

4. `safety_invalid_threshold.md` - Invalid threshold value (should error)
```markdown
---
safetySettings:
  hate_speech: INVALID_THRESHOLD
---

Test error handling.
```

**Acceptance Criteria**:
- [x] Config struct has SafetySettings map
- [x] Valid harm categories parsed correctly
- [x] Valid thresholds parsed correctly
- [x] Invalid categories produce clear error messages
- [x] Invalid thresholds produce clear error messages
- [x] Default BLOCK_NONE applies when safetySettings not specified
- [x] Partial configuration (only some categories) works correctly
- [x] Manual testing with all test templates succeeds

---

### Task 8: Wybór modelu
**Estimated effort**: 45 minutes

**Goal**: Allow users to specify which Gemini model to use via YAML frontmatter.

**Add to `Config` struct**:
```go
type Config struct {
    // ... existing fields ...
    
    // Model selection
    Model string `yaml:"model"`  // e.g., "gemini-2.0-flash-001", "gemini-1.5-pro"
}
```

**Add model validation**:
```go
func validateModel(model string) error {
    // List of supported models
    supportedModels := []string{
        "gemini-2.0-flash-001",
        "gemini-1.5-pro-002",
        "gemini-1.5-pro-001",
        "gemini-1.5-flash-002",
        "gemini-1.5-flash-001",
    }
    
    for _, supported := range supportedModels {
        if model == supported {
            return nil
        }
    }
    
    return fmt.Errorf("unsupported model: %s (supported: %v)", model, supportedModels)
}
```

**Update `callVertexAI()`**:
```go
func callVertexAI(ctx context.Context, config Config, prompt string) (string, error) {
    projectID := os.Getenv("GOOGLE_CLOUD_PROJECT")
    location := os.Getenv("GOOGLE_CLOUD_LOCATION")
    if location == "" {
        location = "europe-west1"
    }
    
    if projectID == "" {
        return "", fmt.Errorf("GOOGLE_CLOUD_PROJECT environment variable not set")
    }
    
    // Model selection with default
    model := "gemini-2.0-flash-001"
    if config.Model != "" {
        if err := validateModel(config.Model); err != nil {
            return "", err
        }
        model = config.Model
    }
    
    // ... client setup ...
    
    req := &aiplatformpb.GenerateContentRequest{
        Model: fmt.Sprintf("projects/%s/locations/%s/publishers/google/models/%s", 
                          projectID, location, model),
        // ... rest of request ...
    }
    
    // ...
}
```

**Test cases to create**:
1. `model_default.md` - No model specified (use default)
```markdown
---
temperature: 0.5
---

Use default model.
```

2. `model_flash.md` - Explicitly specify flash model
```markdown
---
model: gemini-2.0-flash-001
---

Use flash model explicitly.
```

3. `model_pro.md` - Use pro model
```markdown
---
model: gemini-1.5-pro-002
---

Use pro model for complex task.
```

4. `model_invalid.md` - Invalid model name (should error)
```markdown
---
model: gemini-99.9-invalid
---

Test error handling.
```

**Acceptance Criteria**:
- [x] Config struct has Model field
- [x] Default model (gemini-2.0-flash-001) used when not specified
- [x] Specified model used when provided
- [x] Model validation catches unsupported models
- [x] Clear error message for unsupported models
- [x] Manual testing with all test templates succeeds

---

## Integration & Testing Plan

### End-to-End Test Scenarios

**Scenario 1: Full configuration**
```markdown
---
model: gemini-1.5-pro-002
temperature: 0.8
topP: 0.9
maxTokens: 4096
responseMimeType: text/plain
safetySettings:
  hate_speech: BLOCK_MEDIUM_AND_ABOVE
  harassment: BLOCK_LOW_AND_ABOVE
---

Write a creative story about a robot learning to paint.
```

Expected: Story generated using Pro model with specified parameters.

**Scenario 2: Minimal configuration**
```markdown
---
temperature: 1.0
---

Be very creative!
```

Expected: Uses defaults for all unspecified parameters.

**Scenario 3: JSON output with schema (for future M4)**
```markdown
---
temperature: 0.0
responseMimeType: application/json
---

List three colors in JSON format with properties: name, hex.
```

Expected: Structured JSON response.

### Error Handling Test Matrix

| Scenario | Expected Behavior | Exit Code |
|----------|------------------|-----------|
| Valid config | AI response with custom params | 0 |
| No config section | Uses all defaults | 0 |
| Invalid safety category | Error: "unknown harm category: X" | 1 |
| Invalid safety threshold | Error: "unknown safety threshold: X" | 1 |
| Invalid model | Error: "unsupported model: X" | 1 |
| Temperature out of range | Accepted (Vertex AI validates) | 0 or 1 |
| Negative maxTokens | Accepted (Vertex AI validates) | 0 or 1 |

**Note**: Some validations (like temperature range 0-2) could be added in M5 for better UX.

### Example Templates to Create

Create in `examples/` directory:

1. **examples/creative_story.md**
```markdown
---
model: gemini-1.5-pro-002
temperature: 0.9
topP: 0.95
maxTokens: 2048
responseMimeType: text/plain
---

Write a short creative story about a time-traveling cat.
```

2. **examples/deterministic_analysis.md**
```markdown
---
temperature: 0.0
topP: 1.0
responseMimeType: application/json
---

Analyze the sentiment of this text: "I love sunny days!"
Return JSON with: sentiment (positive/negative/neutral), confidence (0-1).
```

3. **examples/safe_content.md**
```markdown
---
safetySettings:
  hate_speech: BLOCK_LOW_AND_ABOVE
  dangerous_content: BLOCK_LOW_AND_ABOVE
  sexually_explicit: BLOCK_LOW_AND_ABOVE
  harassment: BLOCK_LOW_AND_ABOVE
responseMimeType: text/plain
---

Write child-friendly content about marine animals.
```

---

## Updated Config Struct (Complete)

```go
type Config struct {
    // Generation parameters
    Temperature      *float32          `yaml:"temperature"`
    TopP             *float32          `yaml:"topP"`
    MaxTokens        *int32            `yaml:"maxTokens"`
    ResponseMimeType string            `yaml:"responseMimeType"`
    
    // Model selection
    Model            string            `yaml:"model"`
    
    // Safety settings
    SafetySettings   map[string]string `yaml:"safetySettings"`
}
```

---

## Documentation Updates

### Update `.env.example`
No changes needed - env vars unchanged.

### Update example templates
Replace placeholder configs in existing examples:

**examples/hello.md**
```markdown
---
temperature: 0.5
responseMimeType: text/plain
---

Write a short greeting in Polish.
```

**examples/haiku.md**
```markdown
---
temperature: 0.8
model: gemini-2.0-flash-001
responseMimeType: text/plain
---

Write a haiku about Go programming.
```

### Create configuration reference document

**docs/config-reference.md** (new file):
```markdown
# YAML Configuration Reference

## Generation Parameters

### temperature (float, optional)
Controls randomness in output generation.
- Range: 0.0 to 2.0
- Default: 0.0
- Lower = more deterministic, Higher = more creative

### topP (float, optional)
Nucleus sampling parameter.
- Range: 0.0 to 1.0
- Default: 0.95

### maxTokens (integer, optional)
Maximum output tokens to generate.
- Default: 8192
- Higher values allow longer responses

### responseMimeType (string, optional)
Output format.
- Options: "application/json", "text/plain"
- Default: "application/json"

## Model Selection

### model (string, optional)
Gemini model to use.
- Default: "gemini-2.0-flash-001"
- Supported models:
  - gemini-2.0-flash-001 (fastest, default)
  - gemini-1.5-pro-002 (most capable)
  - gemini-1.5-pro-001
  - gemini-1.5-flash-002
  - gemini-1.5-flash-001

## Safety Settings

### safetySettings (map, optional)
Configure content filtering per harm category.

Categories:
- hate_speech
- dangerous_content
- sexually_explicit
- harassment

Thresholds:
- BLOCK_NONE (default)
- BLOCK_ONLY_HIGH
- BLOCK_MEDIUM_AND_ABOVE
- BLOCK_LOW_AND_ABOVE

Example:
\`\`\`yaml
safetySettings:
  hate_speech: BLOCK_MEDIUM_AND_ABOVE
  harassment: BLOCK_LOW_AND_ABOVE
\`\`\`
```

---

## Code Organization (for this milestone)

```
air/
├── main.go                     # All code still here (refactor in M5)
├── go.mod                 
├── go.sum
├── .env
├── .env.example
├── Makefile
├── README.md
├── ROADMAP.md
├── AGENTS.md
├── examples/                   # UPDATED - Add new examples
│   ├── hello.md               # Updated with config
│   ├── haiku.md               # Updated with config
│   ├── no_frontmatter.md      # Unchanged
│   ├── creative_story.md      # NEW
│   ├── deterministic_analysis.md  # NEW
│   └── safe_content.md        # NEW
├── test_templates/             # EXPANDED - Add M2 test cases
│   ├── with_frontmatter.md
│   ├── invalid_yaml.md
│   ├── unclosed_frontmatter.md
│   ├── generation_params_full.md      # NEW
│   ├── generation_params_partial.md   # NEW
│   ├── generation_params_zero.md      # NEW
│   ├── safety_custom.md               # NEW
│   ├── safety_invalid_category.md     # NEW
│   ├── safety_invalid_threshold.md    # NEW
│   ├── model_flash.md                 # NEW
│   ├── model_pro.md                   # NEW
│   └── model_invalid.md               # NEW
├── docs/                       # NEW
│   └── config-reference.md     # NEW - Configuration documentation
└── plans/
    ├── m1.md
    └── m2.md                   # This file
```

---

## Definition of Done

Milestone 2 is complete when:
- [x] Config struct expanded with all M2 fields
- [x] Task 6: Generation parameters (temperature, topP, maxTokens, responseMimeType) working
- [x] Task 7: Safety settings configurable and working
- [x] Task 8: Model selection configurable and working
- [x] All test templates created and tested
- [x] Error handling for invalid configurations tested
- [x] Example templates updated and new ones created
- [ ] Configuration reference documentation created
- [x] Code builds without warnings: `make build`
- [x] Manual end-to-end testing passed for all scenarios
- [x] Backward compatibility: templates without frontmatter still work
- [x] Ready to use in real-world scenarios with custom configurations

---

## Next Steps (Milestone 3 Preview)

Once M2 is complete, Milestone 3 will add:
- File inclusion: `{{include "path/to/file.md"}}`
- Placeholder replacement: `{{variable_name}}`
- Variable passing via CLI flags: `./air template.md --var name=value`
- Variables from environment and frontmatter

These features enable building complex prompts from reusable components.

---

## Time Estimate

Total estimated effort: **3-4 hours**

- Task 6 (Generation params): 1 hour
- Task 7 (Safety settings): 1.5 hours
- Task 8 (Model selection): 45 min
- Integration & testing: 45 min
- Documentation: 30 min

**Target completion**: Single development session

---

## Risks & Mitigations

### Risk 1: Type conversion edge cases
**Problem**: float32 vs float64, pointer dereferencing
**Mitigation**: 
- Use consistent float32 types (matching protobuf)
- Test with various numeric formats in YAML
- Test nil pointer cases explicitly

### Risk 2: Safety settings partial configuration
**Problem**: User specifies only some categories - what about others?
**Mitigation**: 
- Current approach: only specified categories get sent to API
- API may apply its own defaults for unspecified categories
- Document this behavior in config reference
- Consider extending in M5 to merge with defaults

### Risk 3: Model name changes
**Problem**: Google may deprecate/rename models
**Mitigation**:
- Centralize supported models list in one place
- Easy to update when new models released
- Consider adding a `--list-models` flag in M5

### Risk 4: Vertex AI parameter validation
**Problem**: Some invalid values accepted by our code but rejected by API
**Mitigation**:
- Let Vertex AI do primary validation
- Add basic range checks in M5 if needed
- Focus on clear error propagation from API errors

---

## Notes

- Keep all code in `main.go` for this milestone (refactor in M5)
- Focus on correctness over optimization
- Use pointer types (*float32, *int32) for optional numeric parameters
- YAML parsing handles pointers automatically (nil if not specified)
- Error messages should mention which config field caused the problem
- Test both presence and absence of each config field
- Ensure backward compatibility: old templates without M2 configs still work

---

## Testing Checklist

Before marking M2 complete, manually test:

- [ ] Template with no frontmatter works (uses all defaults)
- [ ] Template with empty frontmatter works (uses all defaults)
- [ ] temperature: 0.0 produces deterministic output
- [ ] temperature: 1.0 produces creative output
- [ ] Different models (flash vs pro) both work
- [ ] Invalid model name shows clear error
- [ ] Safety settings with valid categories work
- [ ] Invalid safety category shows clear error
- [ ] Invalid safety threshold shows clear error
- [ ] responseMimeType: text/plain returns plain text
- [ ] responseMimeType: application/json returns JSON
- [ ] Mixing M2 configs with future M1-style templates works
- [ ] All example templates run successfully
- [ ] Build process clean: no warnings, no errors
